// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1024.Emmet.subsystems;

import org.usfirst.frc1024.Emmet.Robot;
import org.usfirst.frc1024.Emmet.RobotMap;
import org.usfirst.frc1024.Emmet.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Drivetrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static CANTalon rightFront = RobotMap.drivetrainRightFront;
    public static CANTalon rightRear = RobotMap.drivetrainRightRear;
    public static CANTalon leftFront = RobotMap.drivetrainLeftFront;
    public static CANTalon leftRear = RobotMap.drivetrainLeftRear;
    public static CANTalon slide1 = RobotMap.drivetrainSlide1;
    public static CANTalon slide2 = RobotMap.drivetrainSlide2;
    public static AnalogGyro gyro = RobotMap.drivetrainGyro;
    public static AnalogInput rightUltra = RobotMap.drivetrainRightUltra;
    public static AnalogInput leftUltra = RobotMap.drivetrainLeftUltra;
    public static Encoder rightEncoder = RobotMap.drivetrainRightEncoder;
    public static Encoder leftEncoder = RobotMap.drivetrainLeftEncoder;
    public static Encoder slideEncoder1 = RobotMap.drivetrainSlideEncoder1;
    public static Encoder slideEncoder2 = RobotMap.drivetrainSlideEncoder2;
    public static Solenoid slideActuator = RobotMap.drivetrainSlideActuator;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new Drive());
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public static void DriveMotors(double lSpeed, double rSpeed, double sSpeed){
    	rightFront.set(rSpeed);
    	rightRear.set(rSpeed);
    	leftFront.set(-lSpeed);
    	leftRear.set(-lSpeed);
    	slide1.set(-sSpeed);
    	slide2.set(-sSpeed);
    }
    public static void DriveForward(double speed, double time) {
    	DriveMotors(-speed, -speed, 0);
    	Timer.delay(time);
    	DriveMotors(0,0,0);
    }
    public void DriveBackward(double speed) {
    	DriveMotors(speed, speed, 0);
    }
    public static void DriveStraightInches(double speed, double distance){
    	double gyroPConstant = 20;
    	rightEncoder.reset();
    	leftEncoder.reset();
    	speed = Math.abs(speed);
    	if(distance > 0){
    		while((/*rightEncoder.getDistance()<6*Robot.encoderConstantInches && */leftEncoder.getDistance() < 6*Robot.encoderConstantInches) && (Robot.oi.xBox.getRawButton(2)==false)){
    			DriveMotors((-speed/2), -(speed/2), 0);
    		}
    		gyro.reset();
    		while((/*rightEncoder.getDistance()<distance*Robot.encoderConstantInches && */leftEncoder.getDistance() < distance*Robot.encoderConstantInches) && (Robot.oi.xBox.getRawButton(2)==false)){
    			DriveMotors(-speed + (gyro.getAngle()/gyroPConstant), -speed-(gyro.getAngle()/gyroPConstant), 0);
    		}
    	}else if(distance<0){
    		while((/*rightEncoder.getDistance()>-6*Robot.encoderConstantInches && */leftEncoder.getDistance() > -6*Robot.encoderConstantInches) && Robot.oi.xBox.getRawButton(2)==false){
    			DriveMotors((speed/2), (speed/2), 0);
    		}
    		gyro.reset();
    		while((/*rightEncoder.getDistance()>distance*Robot.encoderConstantInches && */leftEncoder.getDistance() > distance*Robot.encoderConstantInches) && Robot.oi.xBox.getRawButton(2)==false){
    			DriveMotors(speed + (gyro.getAngle()/gyroPConstant), speed-(gyro.getAngle()/gyroPConstant), 0);
    		}
    	}
    }
    /*
    public static void DriveStraightFeet(double speed, double distance){
    	double gyroPConstant = 15;
    	rightEncoder.reset();
    	leftEncoder.reset();
    	speed=Math.abs(speed);
    	if(distance>0){
    		while((rightEncoder.getDistance()<6*Robot.encoderConstantInches) && (Robot.oi.xBox.getRawButton(2)==false)){
    			DriveMotors((-speed/2), -(speed/2), 0);
    		}
    		gyro.reset();
    		while((rightEncoder.getDistance()<distance*Robot.encoderConstantFeet) && (Robot.oi.xBox.getRawButton(2)==false)){
    			DriveMotors(-speed+(gyro.getAngle()/gyroPConstant), -speed-(gyro.getAngle()/gyroPConstant), 0);
    		}
    	}else if(distance<0){
    		while((rightEncoder.getDistance()>-6*Robot.encoderConstantInches) && (Robot.oi.xBox.getRawButton(2)==false)){
    			DriveMotors((speed/2), (speed/2), 0);
    		}
    		gyro.reset();
    		while((rightEncoder.getDistance()>distance*Robot.encoderConstantFeet) && (Robot.oi.xBox.getRawButton(2)==false)){
    			DriveMotors(speed-(gyro.getAngle()/gyroPConstant), speed+(gyro.getAngle()/gyroPConstant), 0);
    		}
    	}
    }
    */
    public static void turnRight(double speed, int angle){
    	gyro.reset();
    	DriveMotors(-speed/2, speed/2, 0);
    	Timer.delay(0.1);
    	while((gyro.getAngle()<angle) && (Robot.oi.xBox.getRawButton(2)==false)){
    		DriveMotors(-speed, speed, 0);	
    	}
    	Stop();
    }
    
    public static void turnLeft(double speed, int angle){
    	gyro.reset();
    	DriveMotors(speed/2, -speed/2, 0);
    	Timer.delay(0.1);
    	while((gyro.getAngle()>angle) && (Robot.oi.xBox.getRawButton(2)==false)){
    		DriveMotors(speed, -speed, 0);
    	}
    	Stop();
    }
    
//    public void DriveLeft(double speed) {
//    	DriveMotors(0, 0, -speed);
//    }
//    
//    public void DriveRight(double speed) {
//    	DriveMotors(0, 0, speed);
//    }
    
    public static void Stop() {
    	DriveMotors(0, 0, 0);
    }
    
    public static void stepCommonSB(int distance){
    	Wings.Up();  //start the lift to drop the stop blocks
    	Drivetrain.DriveStraightInches(0.4, -10); //Drive between totes
    	Wings.Down();  //drop the wings for pickup
    	Drivetrain.DriveStraightInches(0.35, distance); //Drive to step
    	Drivetrain.DriveMotors(.25,.25,0);  //ensure we are square on the step
    	Timer.delay(0.5); //Square off on step
    	Drivetrain.Stop();
    	Wings.Up();  //pick up the RC wings
    	Timer.delay(2); //Wait for the wings to go up
    	Drivetrain.DriveStraightInches(0.35, 136); //Drive into auto zone
    	Drivetrain.Stop();
    }
    
    public static void stepCommonWU(int distance){
    	Wings.Down();
		Drivetrain.DriveStraightInches(0.5, distance); //Drive to step
		Drivetrain.DriveMotors(.25, .25, 0); //ensure we are square on the step
    	Timer.delay(0.5); //Square off on step
    	Drivetrain.Stop();
    	Wings.Up();
    	Timer.delay(2); //Wait for the wings to go up
    	Drivetrain.DriveStraightInches(0.35, 148); //Drive into auto zone
    	Drivetrain.Stop();
    }
}
    


